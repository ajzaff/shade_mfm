//include "cpu_gpu_shared.inl"
//include "uniforms.inl"
//include "defines.inl"
//include "globals.inl"
//include "prng.inl"
//include "atom_decls.inl"
//include "bit_packing.inl"
//include "sites.inl"
//include "atoms.inl"
//include "xoroshiro128starstar.inl"

void main() {
	uvec2 size = imageSize(img_site_bits);
	ivec2 center_idx = ivec2(gl_GlobalInvocationID.xy);

	// threads may be scheduled "off the image" because they come in blocks, so make sure our thread is actually on top of a valid site
	if (center_idx.x < size.x && center_idx.y < size.y) { 
		_SITE_IDX = center_idx;
		_SYMMETRY = cSYMMETRY_000L;
			
		uvec4 D = imageLoad(img_dev, center_idx);
		Atom A = _SITE_LOAD(ivec2(0));
		atomicAdd(stats.counts[min(_UNPACK_TYPE(A), TYPE_COUNTS-1)], 1);

		uint event_count = imageLoad(img_event_count, center_idx).x;
		//if (D.z == 1) { //#HACK site updated signal
			//atomicAdd(stats.event_count_this_batch, 1);
			//event_count += 1;
			//imageStore(img_event_count, center_idx, uvec4(event_count));
		//}
		atomicMin(stats.event_count_min, event_count);
		atomicMax(stats.event_count_max, event_count);

		if (center_idx == site_info_idx) {
			site_info.dev = D;
			site_info.event_layer = A;
		}
	}
}